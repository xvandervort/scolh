1/21
  MISSING FEATURE: When someone pays, there should be an entry referring to WHAT they are paying for, even if it's just a text string explaining the consideration. In particular, think ahead. Suppose a smart contract encodes a payment to be triggered as a penalty for late delivery of goods. Shouldn't there be a label on that payment explaining that? Of course, in the future there's a plan to have "triggers" for payment. But does that necessarily satisfy the condition? There should be a human-readable string explaining it as well. There is, however, some danger that lazy people will fill in the string with something like, "payment for services rendered." That's not good. 
    Another approach might be to have an overall purpose or type for the contract. And an idea whether it's a one-off or some kind of ongoing relationship.
    Simplest example, though is, what about a fine for late payment, such as when a credit card payment is late? That is sometimes calculated by an equation (such as 0.1% of outstanding balance) and has a specific trigger (no on-time payment registered). It's a very interesting TYPE of payment. Maybe Then, there are a couple of things that need to be added here. Payment types, triggers (which is partially built in to type), checks (has payment been made?), explanations (that can be attached to almost anything).
    Updating todo.txt accordingly.

  BUT another issue comes up now. That is, can the code generated from this code DO anything. Can we run simulations of how they would perform under certain conditions? At the moment, obviously not. But in the long run there should be a simulated blockchain for the simulated contract to interact with. A simple database with contract-like API should do that just fine. Hmmmm. Actually, the chain needs to have some awareness of the addresses involved and a sense of time. Well, this is not for now.


1/6/2017
  NOW: using Erb to process some basic code templates. Nothing like a full contract yet, just translating (currently) the party objects to javascript code. In theory, converting all the little pieces using consistent variable and function names should make compiling a final result easy. 

  BUG: Payments are not paid from person to person but from address to address. In expressing a payment, the correct address needs to be looked up somewhere. One way to resolve this is that every time a new payment and/or party is added to the list, do a correlation step.

  NEXT:
    1. Test code generation with varying conditions (such as missing addresses)
    2. Redirect generated code to an output file if desired
    3. Run checks before outputting code (unless overridden?)
    4. There is no four.
    5. Fix the above bug.
    6. Develop some boilerplate code?

12/11
  Realized today that there's an important feature missing: Time. A contract has a start date and an end condition (which might be time, it might be delivery of goods or other thing). Different terms might also have a time component but for now, I'm just going to encode the start date. There should be other ways of doing it, such as "contract enters into force 10 days after signing by all parties." To do that, I'm going to have to encode events but that's a long way off! To do events, you also need oracles. Actually, to do time correctly, you need to also encode time zones. Hmmm. I'll have to think about that.
  
  Anyway: NOW: Add a parameter for date (and optionally time?) of term.
  NEXT: When do we get to code generation?

12/1
  Dummy parameter.
  
  THOUGHT: Should create a module that defines a good coin address and transaction parameters - for a fictional coin (that just happens to look a lot like Ether) - to use as an example. It would make for a much more robust simulation. But that's probably not for today.

10/1
  WAIT! This is a proof of concept. A "valid" address definition does not need to be perfectly configurable. It DOES need to accept something more or less real. For now the checking module will validate anything between 27 and 40 characters if those characters are 0-9 and A-E. In production it should be possible to load from a set of known types or even load a custom made validation module. But that's a bit of overkill now.
  NEXT? Now that we're validating addresses, maybe you should have a 'dummy' parameter or an 'autogenerate' parameter.

9/27
  Adding validation that each party has a payment address.
  NOTE: checking whether payment address is valid requires configuration per instance. That is, a Bitcoin address is different from Ether is different from Litecoin, etc. (Though sometimes differences are small, they count). How to specify valid address standards?
  SOON: Load statements from a file (because it's so much easier than testing this thing by typing stuff into the shell)
  ALSO: Before code will print, you have to pass checks (though it should be possible to disable individual checks)

9/25
  Creating a class to output contract code (stubs). In javascript? Or ruby?
  Okay. There's a basic implementation that outputs a dummy string instead of code.
  Actually generating something that looks like code is next.
  EXCEPT: Maybe it's time to do some validation (token started). Because you want to run validation before trying to compile the code, so as to avoid generating a bogus contract.
  NEXT: More validations.
  THEN: Back to generating something like contract code.
  AND THEN: How about a help command?

9/12
  Bitcoin style addresses may be given at creation or later. Creation = done.
  Update requires locating the thing to be updated first. Not important now.

9-8-2016
  Instituting cheap version of list command. 
  Don't forget to gut the run command and replace it with an interpreter.
  Should parties be numbered? (so that instead of saying 'jim' it would say 'party 1, aka jim'). Add that to the backog, someday when there is one.
  NEXT: Parties must have Bitcoin style addresses! (before outputting code stubs. It isn't a proof of concept without the concept, after all)

9-7-2016
  Payments have four terms: Who pays, who to, how much and when. Long run: how much and when could be dependent on some other things like delivery schedules, milestones. So, let's see how hard it would be to accomodate that. A payment schedule would be made up of sub payments, each with all of the above terms. BUT, instead of dollar amounts, it could be a percentage of something else.
    So a payment schedule comes later, as do percents. Right now we just go with the 4 major terms.
    Now, how do we express the "who" involved?
      This means I need to do 3 things: List parties. Add an alias to a party ("Joe's Bar and Grill, henceforth referred to as JBG") or list parties by number.
      But for now, let's just do it by name. KISS.
      
  Created payment class.
  NOW: Enter payments from the command line. (DONE)
  NEXT: list current terms (later we'll list them in code as well as in English)
  THEN: output some code stubs for a contract.
  AFTER THAT: Add physical and bitcoin style addresses to identity. THE COIN ADDRESS IS CRITICAL.

9-4-2016
  Project begins. It is only going to be proof of concept quality (meaning low quality, low functionality). This piece provides a human-ish language for specifying simple contract terms. This will in turn generate a config file that can be read into code that will generate finished and workable contract code. 

  Why go to so much trouble? Because humans shouldn't have to know how to code to be able to do ordinary business. Lawyers and judges shouldn't need to learn to code AND the law. Accountants and business folk shouldn't have to learn to code AND accounting and business regulations and such. This should all be easy!

  It is now possible to add parties to the contract (but not their contact or identifying information). 
  NEXT Add payment amounts?
